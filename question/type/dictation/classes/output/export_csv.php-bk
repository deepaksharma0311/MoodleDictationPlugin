<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * CSV export class for dictation questions.
 *
 * @package    qtype_dictation
 * @copyright  2024 Your Name
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

namespace qtype_dictation\output;

defined('MOODLE_INTERNAL') || die();

require_once($CFG->libdir . '/csvlib.class.php');

/**
 * Handles CSV export of dictation question responses.
 */
class export_csv {

    /**
     * Export dictation responses to CSV format.
     *
     * @param int $questionid The question ID to export data for
     * @param int $contextid The context ID
     * @return void
     */
    public static function export_responses($questionid, $contextid) {
        global $DB, $CFG;

        // Get question details
        $question = $DB->get_record('question', array('id' => $questionid), '*', MUST_EXIST);
        $options = $DB->get_record('qtype_dictation_options', array('questionid' => $questionid), '*', MUST_EXIST);
        $gaps = json_decode($options->gaps, true);

        // Get all attempts for this question from the dictation_attempts table
        $sql = "SELECT da.id, da.userid, da.attemptid, da.responses, da.scores, da.totalscore, 
                       da.playcount, da.timecreated, da.timemodified,
                       u.firstname, u.lastname, u.email
                FROM {qtype_dictation_attempts} da
                JOIN {user} u ON u.id = da.userid
                WHERE da.questionid = ?
                ORDER BY u.lastname, u.firstname, da.timemodified";

        $attempts = $DB->get_records_sql($sql, array($questionid));

        if (empty($attempts)) {
            print_error('noattempts', 'qtype_dictation');
        }

        // Prepare CSV data
        $csvdata = array();
        
        // Create header row
        $header = array(
            get_string('exportheader_student', 'qtype_dictation'),
            get_string('exportheader_attempt', 'qtype_dictation'),
            get_string('exportheader_question', 'qtype_dictation')
        );

        // Add gap headers in new format: Q1_Gap1_Response | Q1_Gap1_Score
        for ($i = 0; $i < count($gaps); $i++) {
            $gapnum = $i + 1;
            $header[] = "Q{$questionid}_Gap{$gapnum}_Response";
            $header[] = "Q{$questionid}_Gap{$gapnum}_Score";
        }

        $header[] = get_string('exportheader_totalscore', 'qtype_dictation');
        $header[] = get_string('exportheader_playcount', 'qtype_dictation');
        $header[] = get_string('exportheader_timecreated', 'qtype_dictation');

        $csvdata[] = $header;

        // Process each attempt
        foreach ($attempts as $attempt) {
            $row = array();
            
            // Student info
            $row[] = $attempt->firstname . ' ' . $attempt->lastname;
            $row[] = $attempt->attemptid;
            $row[] = format_string($question->name);

            // Parse responses and scores from JSON
            $responses = json_decode($attempt->responses, true) ?: array();
            $scores = json_decode($attempt->scores, true) ?: array();
            
            // Process each gap - only response and score
            for ($i = 0; $i < count($gaps); $i++) {
                $gapkey = 'gap_' . $i;
                $studentword = isset($responses[$gapkey]) ? $responses[$gapkey] : '';
                $gapscore = isset($scores[$i]) ? $scores[$i] : 0;
                
                $row[] = $studentword;
                $row[] = round($gapscore, 4);
            }

            // Total score
            $row[] = round($attempt->totalscore, 4);
            
            // Play count
            $row[] = $attempt->playcount;
            
            // Time
            $row[] = userdate($attempt->timemodified);

            $csvdata[] = $row;
        }

        // Generate filename
        $filename = get_string('exportfilename', 'qtype_dictation', date('Y-m-d_H-i-s'));
        
        // Output CSV
        $csvexport = new \csv_export_writer();
        $csvexport->set_filename($filename);
        
        foreach ($csvdata as $row) {
            $csvexport->add_data($row);
        }
        
        $csvexport->download_file();
    }



    /**
     * Calculate word score using normalized Levenshtein distance.
     *
     * @param string $correct The correct word
     * @param string $student The student's input
     * @return float Score between 0 and 1
     */
    private static function calculate_word_score($correct, $student) {
        if (empty($correct) && empty($student)) {
            return 1.0;
        }
        
        if (empty($correct) || empty($student)) {
            return 0.0;
        }
        
        // Normalize case for comparison
        $correct = strtolower(trim($correct));
        $student = strtolower(trim($student));
        
        if ($correct === $student) {
            return 1.0;
        }
        
        // Calculate Levenshtein distance
        $distance = levenshtein($correct, $student);
        $maxlength = max(strlen($correct), strlen($student));
        
        // Normalized score: 1 - (distance / max_length)
        return max(0, 1 - ($distance / $maxlength));
    }
}
